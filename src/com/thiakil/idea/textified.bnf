{
  parserClass="com.thiakil.idea.parser.TextifiedAsmParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="TextifiedAsm"
  psiImplClassSuffix="Impl"
  psiPackage="com.thiakil.idea.psi"
  psiImplPackage="com.thiakil.idea.impl"

  elementTypeHolderClass="com.thiakil.idea.psi.TextifiedAsmTypes"
  elementTypeClass="com.thiakil.idea.psi.TextifiedAsmElementType"
  tokenTypeClass="com.thiakil.idea.psi.TextifiedAsmTokenType"
  tokens=[
    comment='regexp:(//.*|/\*.*?\*/)'
    //TYPE='regexp:(\[*([BCDFIJSZ]|L([a-zA-z\$_][a-zA-Z0-9\$_]*/)*[a-zA-z\$_][a-zA-Z0-9\$_]*;))'
    //RESULT_TYPE='regexp:(\[*([BCDFIJSZV]|L([a-zA-z\$_][a-zA-Z0-9\$_]*/)*[a-zA-z\$_][a-zA-Z0-9\$_]*;))'
    PRIMITIVE_TYPE='regexp:([BCDFIJSZ])'
    RESULT_PRIMITIVE='regexp:([BCDFIJSZV])'
    LABEL_ID='regexp:(L\d+)'
    REFERENCE_TYPE='regexp:(L(?:[a-zA-z\$_][a-zA-Z0-9\$_]*/)*[a-zA-z\$_][a-zA-Z0-9\$_]*?;)'
    TYPE_NAME='regexp:(([a-zA-z\$_][a-zA-Z0-9\$_]*/)+[a-zA-z\$_][a-zA-Z0-9\$_]*)'
    identifier='regexp:([a-zA-z\$_][a-zA-Z0-9\$_]*)'
    number='regexp:(\d+(\.\d*)?)'
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    whitespace='regexp:([\n\r\t\f ])'
  ]
}

asmFile ::= TYPE_DECLARATION+

CLASS_DECLARATION ::= CLASS_MODIFIERS? class CLASS_TYPE SUPER? INTERFACES?

CLASS_DEFINITION ::= CLASS_DECLARATION "{" CLASS_BODY //"}"

INNER_CLASS_DECLARATION ::= FIELD_MODIFIER* INNERCLASS CLASS_TYPE CLASS_TYPE CLASS_TYPE

private TYPE_DECLARATION ::= CLASS_DEFINITION | INTERFACE_DECLARATION

private CLASS_MODIFIERS ::= CLASS_MODIFIER*

CLASS_MODIFIER ::= public | abstract | final

SUPER ::= extends CLASS_TYPE

INTERFACES ::= implements INTERFACE_TYPE_LIST

INTERFACE_TYPE_LIST ::= (INTERFACE_TYPE ",")* INTERFACE_TYPE

CLASS_BODY ::= CLASS_BODY_DECLARATION*

FIELD_DECLARATION ::= FIELD_MODIFIER* TYPE identifier FIELD_INITIALISER? ANNOTATION_ELEMENT*

FIELD_INITIALISER ::= "=" FIELD_INITIALISER_VALUE

FIELD_INITIALISER_VALUE ::= string | number

FIELD_MODIFIER ::= public | protected | private | static | final | transient | volatile | synthetic

METHOD_DECLARATION ::= METHOD_HEADER METHOD_BODY?

private METHOD_HEADER ::= METHOD_MODIFIER* METHOD_DECLARATOR THROWS?

METHOD_MODIFIER ::= public | protected | private | static | abstract | final | synchronized | native | synthetic | bridge | default

private METHOD_DECLARATOR ::= METHOD_IDENTIFIER METHOD_DESC ANNOTATION_ELEMENT*

METHOD_DESC ::= METHOD_PARAM RESULT_TYPE

private METHOD_PARAM ::= '(' FORMAL_PARAMETER* ')'

METHOD_IDENTIFIER ::= identifier | <init> | <clinit>

METHOD_BODY ::= METHOD_BODY_ELEMENT* MAX_ELS*

private MAX_ELS ::= MAX_STACK | MAX_LOCALS

MAX_STACK ::= MAXSTACK "=" number

MAX_LOCALS ::= MAXLOCALS "=" number

FORMAL_PARAMETER ::= TYPE

THROWS ::= "throws" CLASS_TYPE_LIST

private CLASS_BODY_DECLARATION ::= INNER_CLASS_DECLARATION | FIELD_DECLARATION | METHOD_DECLARATION

CLASS_TYPE_LIST ::= (CLASS_TYPE ",")* CLASS_TYPE

INTERFACE_DECLARATION ::= INTERFACE_MODIFIERS interface INTERFACE_TYPE EXTENDS_INTERFACES? "{" INTERFACE_BODY// "}"

INTERFACE_MODIFIERS ::= INTERFACE_MODIFIER*

private INTERFACE_MODIFIER ::= public | abstract

EXTENDS_INTERFACES ::= implements (INTERFACE_TYPE ",")* INTERFACE_TYPE

INTERFACE_BODY ::= INTERFACE_MEMBER_DECLARATION*

private INTERFACE_MEMBER_DECLARATION ::= CONSTANT_DECLARATION | METHOD_DECLARATION | ANNOTATION_ELEMENT

CONSTANT_DECLARATION ::= CONSTANT_MODIFIER* REFERENCE_TYPE identifier

CONSTANT_MODIFIER ::= public | static | final

//PRIMITIVE_TYPE ::= (B|C|D|F|I|J|S|Z)

//REFERENCE_TYPE ::= (L{CLASS_TYPE}";")

ARRAY_TYPE ::= ("["+PRIMITIVE_TYPE) | ("["+REFERENCE_TYPE)

TYPE ::= ARRAY_TYPE| REFERENCE_TYPE | PRIMITIVE_TYPE

RESULT_TYPE ::= TYPE | 'V'

CLASS_TYPE ::= TYPE_NAME | identifier

INTERFACE_TYPE ::= TYPE_NAME

//TYPE_NAME ::= (id"/")*id

//PACKAGE_NAME ::= PACKAGE_PART+

//PACKAGE_PART ::= id "/"

ANNOTATION_ELEMENT ::= "@" REFERENCE_TYPE "(" ")"

private METHOD_BODY_ELEMENT ::= LABEL_DECLARATION | INSTRUCTION_KIND

LABEL_DECLARATION ::= LABEL_ID

private INSTRUCTION_KIND ::= INSTRUCTION | INSTRUCTION_WITH_ARGS

INSTRUCTION ::= NOP | ACONST_NULL | ICONST_M1 | ICONST_0 | ICONST_1 | ICONST_2 | ICONST_3 | ICONST_4 | ICONST_5 | LCONST_0 | LCONST_1 | FCONST_0 | FCONST_1 | FCONST_2 | DCONST_0 | DCONST_1 | IALOAD | LALOAD | FALOAD | DALOAD | AALOAD | BALOAD | CALOAD | SALOAD | IASTORE | LASTORE | FASTORE | DASTORE | AASTORE | BASTORE | CASTORE | SASTORE | POP | POP2 | DUP | DUP_X1 | DUP_X2 | DUP2 | DUP2_X1 | DUP2_X2 | SWAP | IADD | LADD | FADD | DADD | ISUB | LSUB | FSUB | DSUB | IMUL | LMUL | FMUL | DMUL | IDIV | LDIV | FDIV | DDIV | IREM | LREM | FREM | DREM | INEG | LNEG | FNEG | DNEG | ISHL | LSHL | ISHR | LSHR | IUSHR | LUSHR | IAND | LAND | IOR | LOR | IXOR | LXOR | I2L | I2F | I2D | L2I | L2F | L2D | F2I | F2L | F2D | D2I | D2L | D2F | I2B | I2C | I2S | LCMP | FCMPL | FCMPG | DCMPL | DCMPG | IRETURN | LRETURN | FRETURN | DRETURN | ARETURN | RETURN | ARRAYLENGTH | ATHROW | MONITORENTER | MONITOREXIT

private INSTRUCTION_WITH_ARGS ::= LINE_NUMBER | NEW_INSN | LDC_INSN | ALOAD_INSN | INVOKE_SPECIAL | BI_PUSH | PUT_FIELD

LINE_NUMBER ::= LINENUMBER number LABEL_ID

NEW_INSN ::= NEW TYPE_NAME

LDC_INSN ::= LDC LDC_ARG

private LDC_ARG ::= string | number

ALOAD_INSN ::= ALOAD number

INVOKE_SPECIAL ::= INVOKESPECIAL CLASS_TYPE "." METHOD_IDENTIFIER METHOD_DESC

BI_PUSH ::= BIPUSH number

PUT_FIELD ::= PUTFIELD CLASS_TYPE "." identifier ":" TYPE {name("PUT_FIELD")="what"}